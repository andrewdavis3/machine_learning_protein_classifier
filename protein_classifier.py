#!/usr/bin/env python3
"""
Protein Sequence Classifier for Bioinformatics
Predicts whether a protein sequence is an enzyme based on amino acid composition
"""

import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
import pandas as pd
import warnings


class ProteinClassifier:
    """ML classifier for protein sequences"""
    
    def __init__(self):
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.amino_acids = list('ACDEFGHIKLMNPQRSTVWY')
        
    def extract_features(self, sequence):
        """
        Extract amino acid composition features from protein sequence
        Returns a feature vector of amino acid frequencies
        """
        sequence = sequence.upper()
        total = len(sequence)
        
        # Calculate frequency of each amino acid
        features = []
        for aa in self.amino_acids:
            freq = sequence.count(aa) / total if total > 0 else 0
            features.append(freq)
        
        # Add sequence length as a feature
        features.append(total)
        
        return np.array(features)
    
    def prepare_data(self, sequences, labels):
        """Convert sequences to feature matrix"""
        X = np.array([self.extract_features(seq) for seq in sequences])
        y = np.array(labels)
        return X, y
    
    def train(self, sequences, labels):
        """Train the classifier"""
        X, y = self.prepare_data(sequences, labels)
        self.model.fit(X, y)
        return self
    
    def predict(self, sequences):
        """Predict labels for new sequences"""
        X = np.array([self.extract_features(seq) for seq in sequences])
        return self.model.predict(X)
    
    def predict_proba(self, sequences):
        """Get prediction probabilities"""
        X = np.array([self.extract_features(seq) for seq in sequences])
        return self.model.predict_proba(X)


def generate_sample_data():
    """
    Generate synthetic protein sequences for demonstration
    In practice, you'd load real sequences from FASTA files or databases
    
    Note: These are simplified examples. Real enzymes have more diverse sequences.
    """
    # Enzyme-like sequences (based on real enzyme characteristics)
    enzymes = [
        # Kinase-like
        "MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVKALPDAQFEVVHSLAKWKRQTLGQHDFSAGEGLYTHMKALRPDEDRLSPLHSVYVDQWDWERVMGDGERQFSTLKSTVEAIWAGIKATEAAVSEEFGLAPFLPDQIHFVHSQELLSRYPDLDAKGRERAIAKDLGAVFLVGIGGKLSDGHRHDVRAPDYDDWSTPSELGHAGLNGDILVWNPVLEDAFELSSMGIRVDADTLKHQLALTGDEDRLELEWHQALLRGEMPQTIGGGIGQSRLTMLLLQLPHIGQVQAGVWPAAVRESVPSL",
        # Rhodopsin-like
        "MNGTEGPNFYVPFSNKTGVVRSPFEAPQYYLAEPWQFSMLAAYMFLLIMLGFPINFLTLYVTVQHKKLRTPLNYILLNLAVADLFMVFGGFTTTLYTSLHGYFVFGPTGCNLEGFFATLGGEIALWSLVVLAIERYVVVCKPMSNFRFGENHAIMGVAFTWVMALACAAPPLVGWSRYIPEGMQCSCGIDYYTPHEETNNESFVIYMFVVHFIIPLIVIFFCYGQLVFTVKEAAAQQQESATTQKAEKEVTRMVIIMVIAFLICWLPYAGVAFYIFTHQGSDFGPIFMTIPAFFAKTSAVYNPVIYIMMNKQFRNCMVTTLCCGKNPLGDDEASTTVSKTETSQVAPA",
        # Short enzyme
        "MTEITAAMVKELRESTGAGMMDCKNALSETNGDFDKAVQLLREKGLGKAAKKADRLAAEG",
        # Complex enzyme
        "MGSSHHHHHHSSGLVPRGSHMRGPNPTAASLEASAGPFTVRSFTVSRPSGYGAGTVYYPTNAGGTVGAIAIVPGYTARQSSIKWWGPRLASHGFVVITIDTNSTLDQPSSRSSQQMAALRQVASLNGTSSSPIYGKVDTARMGVMGWSMGGGGSLISAANNPSLKAAAPQAPWDSSTNFSSVTVPTLIFACENDSIAPVNSSALPIYDSMSRNAKQFLEINGGSHSCANSGNSNQALIGKKGVAWMKRFMDNDTRYSTFACENPNSTRVSDFRTANCSLEDPAANKARKEAELAAATAEQ",
        # Protease-like
        "MKKLLILTCLVAVALARPKHPIKHQGLPQEVLNENLLRFFVAPFPEVFGKEKVNELSKDIGSESTEDQAMEDIKQMEAESISSSEEIVPNSVEQKHIQKEDVPSERYLGYLEQLLRLKKYKVPQLEIVPNSAEERLHSMKEGIHAQQEP",
        # Dehydrogenase-like
        "MTDKQYLVGDSKIGRLVGLKEETTYDALRCGVTYMDVFKAGNDDHVISLARGKNEGLNYDITKSTFSTEEKGFVTGSIQLALDGKNKHGRGVFREFKSVEDAHLGGGKHKMPTVKITSFNGADLSGVTEAGAALGAGLTAVAAQRKEEGSM",
        # Transferase
        "MAFSDKNHGLNQFVDSSLNTNKAVLSKLNQKDVKRRLKAAEAVVDNQQKRVLTDKISKMNDSNNLEEEFKQLEEEQKKLDKKLAEFQQELEKVRDQLDKLMQQSERINATLNKAKKELEKKTKELESLQEEISLLDSEVNSKKQLFKKQLAAIERKLKEQELKAKEEELESLKEHIEQILRKFDKERQQEVEGLKKNLEKLREKIEQLEKQLEELKELMNKLQEELQEVEGQLKKVTKEAEAKLKELNSKMEELKKQTEEI",
        # Oxidoreductase
        "MPKSKRKAPQETLNGGITDMLTENNERSKELRDLLNQNASTKDKRRKEHEQKKLLDIQKYLEQKLGHLEEQLKESNMSLLNSILEKLEDSVDELSRNQEQLKSEISLIEDEEKHLSQEQKELLLLEKNTNKLLLEKQALEILKEKDELLEKVEMEHQASIMRLGSFTKNAKEKKLKEMERQMQEAEQKVSKDTEELRKLVEELQQLRDQLDELKNKLEELRKQLEAEQQQL",
        # Hydrolase
        "MKWVTFISLLFLFSSAYSRGVFRRDAHKSEVAHRFKDLGEENFKALVLIAFAQYLQQCPFEDHVKLVNEVTEFAKTCVADESAENCDKSLHTLFGDKLCTVATLRETYGEMADCCAKQEPERNECFLQHKDDNPNLPRLVRPEVDVMCTAFHDNEETFLKKYLYEIARRHPYFYAPELLFFAKRYKAAFTECCQAADKAACLLPKLDELRDEGKASSAKQRLKCASLQKFGERAFKAWAVARLSQRFPKAEFAEVSKLVTDLTKVHKECCHGDLLECADDRADLAKYICENQDSISSKLKECCEKPLLEKSHCIAEVENDEMPADLPSLAADFVESKDVCKNYAEAKDVFLGMFLYEYARRHPDYSVVLLLRLAKTYETTLEKCCAAADPHECYAKVFDEFKPLVEEPQNLIKQNCELFEQLGEYKFQNALLVRYTKKVPQVSTPTLVEVSRNLGKVGSKCCKHPEAKRMPCAEDYLSVVLNQLCVLHEKTPVSDRVTKCCTESLVNRRPCFSALEVDETYVPKEFNAETFTFHADICTLSEKERQIKKQTALVELVKHKPKATKEQLKAVMDDFAAFVEKCCKADDKETCFAEEGKKLVAASQAALGL",
        # Lyase
        "MKLLVLGLLLLLSSCSRAEQGIVSEPGNFEKFKDIVGMILDRDGTTAAVRFSSDPHSKYPKFYQLGLDDQYNPAEERGRGERKPGKEKFVEKIVAIVDEIRRVSTTKKSVTVTWLPPRFLHQGKPAEDNGAYQVSFDISKTATCQADKAAVCRLRCTDSGLGGIGYVKSSGLPDVVEIILHDGETFQLTGEPGDYKFVISGAPGADSKPDDFFPSNKDKEPKGDTYKGSIHADFIRGLHSLSYRKNVLSTEWTRPRSTIEGSKLAVSFETTTIDGKPVRTEKYQCDGYVIDNDGNQVDYVQTVKGKPVLQNVGLTCTKDPSVYDKFLADCCVDTAPVIESWYVRVRSRTLDNNGKEISVADLKVLGVNILQTGQTEYYRIVEGMDYYKITTRQLDNGGFISRAERDGKKRYVIQNELEGGIYRGNLLPTSLVDDLVNWKDKKHVPYLRQLRDTIEKRTHSDPTCPKPILHFPPVPDKKNGECWCIPFVSNIDWLNEYQLYPDEKNKEKGYCVKARSTQCPQAIVMFTDGSCHSAVDMKHDQDGLVCVDYEDFKDDVCIGFSKHVNSKCPNPGEITQCPTGTNFNKWCKHPRWPRCNKITVCNPPPVKKRHVCCATLIRGPGKHGQCKWTHCTVQACLDPKFEGYKCPQPWSGLERTATCQKNYRDRCIIKFAPKENCKKEKGFCCPFVFTGDPKHLLLPEKRWGQEKECSKDFQTLYDSMNVWRWEPKK",
    ]
    
    # Non-enzyme structural proteins
    non_enzymes = [
        # Myosin-like
        "MADEEKLPPGWEKRMSRSSGRVYYFNHITNASQWERPSGNSSSGGKNGQGEPARVSAVSIGCGVGVKGYSLVKVGAGNVTMKFDRFDLLKRMHAKPSPDQVGVGVLGGEKVNIPYNAIKDQGAVDSSYPKALEAVRNVAELRGLSKVGVLGKDSQKMLGFAITTQVMSPSNGGLVGDMVGAIAQTGLSNGLSVTAATLTNHFIGPNSSFKQPFAMVAGHCTDKVSFRSMVGPAERGSNGCRVGQVSTLLKPGDKVLIEMARENIKKFFPMLVAAAYTGCGLNGRLSAADIRDLSGGDSSGMGSPQ",
        # Coiled-coil protein
        "GSHMADSNKTMEHDIAILIKKLESKNIDDLEDDNCIILSAEDIEDLKKVMNDKMDKLEKKVEELMNKLQADFDEITEGLRDELKKATEEKARKLAEQAEKYSQKEDKYEEEIKILKVQSEDFHKIIEHLQKEFSKEIAEYKKKNSNLSEELKKLEEKVSTISELGSIIEKTDEKKLAIIDEEMNDIKKEAEELKKK",
        # Histone-like
        "ARTKQTARKSTGGKAPRKQLATKAARKSAPATGGVKKPHRYRPGTVALREIRRYQKSTELLIRKLPFQRLVREIAQDFKTDLRFQSSAVMALQEACEAYLVGLFEDTNLCAIHAKRVTIMPKDIQLARRIRGERA",
        # Proline-rich
        "MPKTPPGSGAARAESGSSAPEAEEKKKGEEPTSTVTPQSLCQVICPDGAVNPCCHVCSQFNNRCQCRLTKPEKCGRHTDKMNQLISSNHFSKGHHHGHHHSNHHSSGHTHSFAKGAGGHRIHSSSPTTRFSSKTTRSSPSPKTTTSTRLFSPHSGRPKSPKTTRSSPLHSSPGKIRPPSSPVRKSHHRTTHSP",
        # Small structural protein
        "PKRKAEGDAKGDKAKVKDEPQRRSARLSAKPAPPKPEPKPKKAPAKKGEKVPKGKKGKADAGKEGNNPAENGDAKTDQAQKAEGAGDAK",
        # DNA-binding protein
        "MSGRGKGGKGLGKGGAKRHRKVLRDNIQGITKPAIRRLARRGGVKRISGLIYEETRGVLKVFLENVIRDAVTYTEHAKRKTVTAMDVVYALKRQGRTLYGFGG",
        # Intermediate filament
        "MASASSSQRGRSGSGNFGGGRGGGFGGNDNFGRGGNFSGRGGFGGSRGGGGYGGSGDGYNGFGNDGGYGGGGPGYSGGSRGYGSGGQGYGNQGSGYGGSGSYDSYNNGGGRGFGGGSGGGFGGGGFGGGGIGGGGFGGGFGSGGGGFGGGGFGGFGGGAGGGDGGILTANEKSTMQELNSRLASYLDKVQALEEANNDLENKIQDWYDKKGPAAIQKNYSPYYNTIDDLKDQIVDLTVGNNKTLLDIDNTRMTRCAGVDAESGWINNFNTSTCQENMNFGECSV",
        # Glycine-rich structural
        "MPRRSSSSSGALASGVPRRPRSCSRCTPRSRRTPPRGPPPRRRSPGALPGPPGPPVPGMPGPPGPPGPPGVPGPPGPPVPGMPGPPGVPGMPGPPGPPGMPGPPGMPGMPGMPGVPGMPGPPGMPGPPGPPGMPGMPGPPGPPGPPGPPGMPGPPGPPGMP",
        # Collagen-like
        "MGPSGPRGLPGPPGAPGPQGFQGPAGEPGEPGQTGPAGARGPAGPPGKAGEDGHPGKPGRPGERGPPGPQGARGLPGTAGLPGMKGHRGFSGLDGAKGDAGPAGPKGEPGSPGENGAPGQMGPRGLPGERGRPGAPGPAGARGNDGATGAAGPPGPTGPAGPPGFPGAVGAKGEAGPQGPRGSEGPQGVRGEPGPPGPAGAAGPAGNPGADGQPGAKGANGAPGIAGAPGFPGARGPSGPQGPGGPPGPKGNSGEPGAPGSKGDTGAKGEPGPVGVQGPPGPAGEEGKRGARGEPGPTGLPGPPGERGGPGSRGFPGADGVAGPKGPAGERGSPGPAGPKGSPGEAGRPGEAGLPGAKGLTGSPGSPGPDGKTGPPGPAGQDGRPGPPGPPGARGQAGVMGFPGPKGAAGEPGKAGERGVPGPPGAVGPAGKDGEAGAQGPPGPAGPAGERGEQGPAGSPGFQGLPGPAGPPGEAGKPGEQGVPGDLGAPGPSGARGERGFPGERGVQGPPGPAGPRGANGAPGNDGAKGDAGAPGAPGSQGAPGLQGMPGERGAAGLPGPKGDRGDAGPKGADGSPGKDGVRGLTGPIGPPGPAGAPGDKGESGPSGPAGPTGARGAPGDRGEPGPPGPAGFAGPPGADGQPGAKGEPGDAGAKGDAGPPGPAGPAGPPGPIGNVGAPGAKGARGSAGPPGATGFPGAAGRVGPPGPSGNAGPPGPPGPAGKEGGKGPRGETGPAGRPGEVGPPGPPGPAGEKGSPGADGPAGAPGTPGPQGIAGQRGVVGLPGQRGERGFPGLPGPSGEPGKQGPSGASGERGPPGPMGPPGLAGPPGESGREGAPGAEGSPGRDGSPGAKGDRGETGPAGPPGAPGAPGAPGPVGPAGKSGDRGETGPAGPAGPVGPVGARGPAGPQGPRGDKGETGEQGDRGIKGHRGFSGLQGPPGPPGSPGEQGPSGASGPAGPRGPPGSAGAPGKDGLNGLPGPIGPPGPRGRTGDAGPVGPPGPPGPPGPPGPPSAGFDFSFLPQPPQEKAHDGGRYYRADDANVVRDRDLEVDTTLKSLSQQIENIRSPEGSRKNPARTCRDLKMCHSDWKSGEYWIDPNQGCNLDAIKVFCNMETGETCVYPTQPSVAQKNWYISKNPKDKRHVWFGESMTDGFQFEYGGQGSDPADVAIQLTFLRLMSTEASQNITYHCKNSIAYMDEETGNLKKAVILQGSNDVELVAEGNKEVHSGRVYSGMGFTDFLKAMKEKGVNLPGKDYRVNVYRLSLPDRPDSSLVGAAHLTGLRLSQTGGKPTPFPLQPD",
        # Membrane structural
        "MNHKVLTLGLLSAALVTQVSADEVRVEVEVAPPAKEVRIKNLLQDMDNLNREIQAVQSESGNMDNMINLKRLSQQSIKMDELQRLYDSNPDVNVPAQVFVQEDKGELRLLSLHQTAPQPVDQWLTPQIGVGAGEQRLEVVQALEQFLVAQQEEGLSVNLNVTIEAQKASRFNLWRRVKETFQGRVQLLQANPILEAFGNAKTIRNEQLARVEEALAQARNAEERNRLLNEMDKQIEANKLTRLQQSLSDWLTSFGEEDKLTLKNQLRDLVKNNDEGGVIALSAARAEFGNDVTSFKLQEAYHDRVKKWQQLRLEEKPSLEELARLAKAEEAARFQHIAEAFRTIEEQRRRLAAHVEKANRTLSEELEGVIREQGANLRELVKYMKEDEGIINWLHAQGQKLSDEINDFVEDVNALLLDSAKSLAQTRLEAVQADRDACQIKAAAVKTLEYSLVPVAEEVVVLQEGKEAIALTLSAQNVALDAAKSWQEVQGSITDLLQEQRDVSRKLQELAAGLGNVKAEVRAQLDTLRTKFAEVEDELGELIRQLQLTQQQKHAADDLKAIQRFLELTQAQTREMANMAAEALQGELKKLVSLAAVNAENESLIAQLTHIDADFEGLKQDLNETESQALALQAETRSQADELVAAFKLFKDKQTDRKLLSVTIDNANIEAIAGDKKLGSVRLVEQALNEADTTARKLEATEETFKRLDAMLTAMEGARQANDRLKAVVTDLGKELEEIRAQLEELEEKMNSLQCQLDEAEQQQRDNLMQLTVKLKAVLAELQAQIARIKDELRQSHEQT",
    ]
    
    # Combine and create labels (1 = enzyme, 0 = non-enzyme)
    sequences = enzymes + non_enzymes
    labels = [1] * len(enzymes) + [0] * len(non_enzymes)
    
    return sequences, labels


def main():
    """Main demonstration function"""
    print("=" * 60)
    print("Protein Sequence Classifier")
    print("=" * 60)
    
    # Generate sample data
    print("\nüìä Generating sample protein sequences...")
    sequences, labels = generate_sample_data()
    print(f"Total sequences: {len(sequences)}")
    print(f"Enzymes: {sum(labels)}, Non-enzymes: {len(labels) - sum(labels)}")
    
    # Split data (larger test size for better evaluation)
    X_train, X_test, y_train, y_test = train_test_split(
        sequences, labels, test_size=0.25, random_state=42, stratify=labels
    )
    
    print(f"Training set: {len(X_train)} sequences")
    print(f"Test set: {len(X_test)} sequences")
    
    # Train classifier
    print("\nüß¨ Training Random Forest classifier...")
    classifier = ProteinClassifier()
    classifier.train(X_train, y_train)
    print("‚úì Training complete!")
    
    # Evaluate
    print("\nüìà Evaluating model performance...")
    predictions = classifier.predict(X_test)
    
    print("\nConfusion Matrix:")
    cm = confusion_matrix(y_test, predictions)
    print(cm)
    print(f"\nTrue Negatives: {cm[0][0]}, False Positives: {cm[0][1]}")
    print(f"False Negatives: {cm[1][0]}, True Positives: {cm[1][1]}")
    
    print("\nClassification Report:")
    # Set zero_division parameter to avoid warnings
    print(classification_report(y_test, predictions, 
                                target_names=['Non-enzyme', 'Enzyme'],
                                zero_division=0))
    
    # Calculate accuracy
    accuracy = (predictions == y_test).sum() / len(y_test)
    print(f"Test Accuracy: {accuracy:.2%}")
    
    # Cross-validation for more robust evaluation
    print("\nüîÑ Performing 5-fold cross-validation...")
    X, y = classifier.prepare_data(sequences, labels)
    cv_scores = cross_val_score(classifier.model, X, y, cv=5)
    print(f"Cross-validation scores: {cv_scores}")
    print(f"Mean CV accuracy: {cv_scores.mean():.2%} (+/- {cv_scores.std() * 2:.2%})")
    
    # Demonstrate prediction on new sequence
    print("\nüî¨ Testing prediction on a new sequence...")
    test_sequence = "MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVK"
    prediction = classifier.predict([test_sequence])[0]
    probabilities = classifier.predict_proba([test_sequence])[0]
    
    print(f"\nSequence: {test_sequence[:50]}...")
    print(f"Prediction: {'Enzyme' if prediction == 1 else 'Non-enzyme'}")
    print(f"Confidence: {max(probabilities):.2%}")
    print(f"Probabilities - Non-enzyme: {probabilities[0]:.2%}, Enzyme: {probabilities[1]:.2%}")
    
    # Feature importance
    print("\nüîç Top 5 most important features:")
    feature_names = classifier.amino_acids + ['Length']
    importances = classifier.model.feature_importances_
    indices = np.argsort(importances)[::-1][:5]
    
    for i, idx in enumerate(indices, 1):
        print(f"{i}. {feature_names[idx]}: {importances[idx]:.4f}")
    
    print("\n" + "=" * 60)
    print("‚úì Analysis complete!")
    print("\nNext steps for real applications:")
    print("- Load sequences from FASTA files using BioPython")
    print("- Use real labeled data from UniProt or other databases")
    print("- Add more sophisticated features (k-mers, physicochemical properties)")
    print("- Try other algorithms (SVM, Neural Networks)")
    print("- Perform hyperparameter tuning with GridSearchCV")
    print("- Consider sequence alignment features")
    print("=" * 60)


if __name__ == "__main__":
    # Suppress sklearn warnings for cleaner output
    warnings.filterwarnings('ignore', category=UserWarning)
    main()
